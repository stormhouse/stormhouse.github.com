<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>stormhouse</title><link>http://stormhouse.github.io/</link><description></description><atom:link href="http://stormhouse.github.io/feeds/encoding.rss.xml" rel="self"></atom:link><lastBuildDate>Mon, 25 Nov 2013 21:11:00 +0800</lastBuildDate><item><title>Base64编码</title><link>http://stormhouse.github.io/posts/2013/base64bian-ma/</link><description>&lt;p&gt;Base64编码是将任意二进制数据转换为可打印的ASCII字符。&lt;/p&gt;
&lt;h3&gt;从8位到6位&lt;/h3&gt;
&lt;p&gt;它是将一个8位字节序列拆散为6位，并为每个6位片段分配一个字符（2^6=64，推之Base64字符集为64个以内，实际65个字符）。Base64的码表为：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Encoding Img" class="align-center" src="/img/encoding-base64-table.png" title="" /&gt;&lt;/p&gt;
&lt;p&gt;来个实例，下图以中文&lt;code&gt;编码&lt;/code&gt;两个字符（utf-8格式）为例：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Encoding Img" class="align-center" src="/img/encoding-base64-1.png" title="" /&gt;&lt;/p&gt;
&lt;p&gt;可以在&lt;a href="http://www.base64encode.org/"&gt;Base64 Decode and Encode - Online&lt;/a&gt;上验证一下结果。&lt;/p&gt;
&lt;h3&gt;补码&lt;/h3&gt;
&lt;p&gt;Base64编码是将二进制截成每6位一个单位，会有二进制序列不能正好平均分成6位块的情况，这时要在序列末尾填充零位，补够总位数是6*8的最小公倍数，任何完全填充的6位组由特殊的第65个符号&lt;code&gt;=&lt;/code&gt;表示。比如ASCII码的字符&lt;code&gt;a&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Encoding Img" class="align-center" src="/img/encoding-base64-2.png" title="" /&gt;&lt;/p&gt;
&lt;h3&gt;用途&lt;/h3&gt;
&lt;p&gt;Base64编码是对二进制序列为操作对象，那对于任意的二进制序列都可以编码，如文件。
在网上搜集了一些Base64编码应用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.zhangxinxu.com/wordpress/2012/04/base64-url-image-%E5%9B%BE%E7%89%87-%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"&gt;CSS中url属性&lt;/a&gt;：适用于小图片，减少HTTP请求数。&lt;/li&gt;
&lt;li&gt;早期电子邮件中&lt;/li&gt;
&lt;li&gt;简单加密：防君子不防小人的加密方式&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/4070693/what-is-the-purpose-of-base-64-encoding-and-why-it-used-in-http-basic-authentica"&gt;HTTP基本认证&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;文件入库：将文件的二进制流转换成文本存入数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;实现&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://stormhouse.github.com/demo/js/base64.html"&gt;JavaScript实现&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;在线工具&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.base64encode.org/"&gt;Base64 Decode and Encode - Online &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://webcodertools.com/imagetobase64converter"&gt;Convert any image into a base64 string&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">stormhouse</dc:creator><pubDate>Mon, 25 Nov 2013 21:11:00 +0800</pubDate><guid>tag:stormhouse.github.io,2013-11-25:posts/2013/base64bian-ma/</guid><category>encoding</category><category>base64</category></item><item><title>URL编码</title><link>http://stormhouse.github.io/posts/2013/urlbian-ma/</link><description>&lt;hr /&gt;
&lt;p&gt;URL(统一资源定位符, Uniform Resource Location)是URI(统一资源标识符, Uniform Resource Identifier)的一种，一般来讲，URL是Internet上用来描述信息资源的字符串，用于客户端访问www服务器或其它服务器的方式。来几个URL：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;ftp&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//host/filepath/&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;// &lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;ftp&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//表示通过文件传输协议FTP访问FTP服务器。  &lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;telnet&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//表示通过远程登录协议Telnet进行远程登录。  &lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;gopher&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//表示通过gopher协议访问Gopher服务器。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当然协议也可以自己扩展。&lt;/p&gt;
&lt;p&gt;这个不扯太多，今天只讨论编码。&lt;/p&gt;
&lt;h3&gt;URL中包括中文&lt;/h3&gt;
&lt;p&gt;看代码，文件名&lt;code&gt;编码-test.html&lt;/code&gt;放到tomcat（全局web.xml配置listings设置成true）下webapp目录下中的encoding目录下&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;meat&lt;/span&gt; &lt;span class="na"&gt;charset=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;utf-8&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;form&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;input&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;q&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;value=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;编码test&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;input&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;submit&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;value=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;submit&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/form&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;浏览器（chrome,IE）访问该文件&lt;code&gt;http://localhost:8080/encoding/&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Encoding Img" class="align-center" src="/img/encoding-http-url1.png" title="" /&gt;&lt;/p&gt;
&lt;p&gt;点击该文件：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Encoding Img" class="align-center" src="/img/encoding-http-url2.png" title="" /&gt;&lt;/p&gt;
&lt;p&gt;得出结论：在浏览器中输入带中文的URL，自动按utf-8编码转换（多了个%）；404，说明服务器端没有正确的编码方式来处理该URL，导致找不到该文件。即浏览器与服务器端（tomcat）不是同一种编码格式来处理URL。幸好以前研究过部分tomcat的源代码，啥也不说，上图：（tomcat-7.0.42版本，CoyoteAdapter.java文件814行）&lt;/p&gt;
&lt;p&gt;&lt;img alt="Encoding Img" class="align-center" src="/img/encoding-http-url3.png" title="" /&gt;&lt;/p&gt;
&lt;p&gt;可以看到，tomcat默认是按US-ASCII编码方式来处理url，显然无法正确处理带中文的文件名。看其注释可知它是可配的，即在&lt;code&gt;${tomcat_home}/conf/server.xml&lt;/code&gt;中Connector节点添加 &lt;code&gt;URIEncoding="UTF-8"&lt;/code&gt;，重起tomcat，再次访问，一切如我所愿。&lt;/p&gt;
&lt;h3&gt;form表单提交中的中文&lt;/h3&gt;
&lt;p&gt;点击&lt;code&gt;编码-test.html&lt;/code&gt;页面中的&lt;code&gt;submit&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Encoding Img" class="align-center" src="/img/encoding-http-url4.png" title="" /&gt;&lt;/p&gt;
&lt;p&gt;对于表单生成（GET）的URL查询字符中有中文，默认按操作系统的编码方式，试想这不乱套了吗，不同语言国家的浏览器访问同一页面，那么提交的数据会变的千奇百怪了吧。还好给表单加个配置&lt;code&gt;accept-charset&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;form&lt;/span&gt; &lt;span class="na"&gt;accept-charset=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;utf-8&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;input&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;q&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;value=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;编码test&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;input&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;submit&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;value=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;submit&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/form&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;刷新页面，再次点击，一切都美好&lt;/p&gt;
&lt;p&gt;&lt;img alt="Encoding Img" class="align-center" src="/img/encoding-http-url5.png" title="" /&gt;&lt;/p&gt;
&lt;h3&gt;Ajax的中文参数&lt;/h3&gt;
&lt;p&gt;首先不去实验一些浏览器的差异性了，因为你不可能不用ajax库，而自己包装XHR对象来实现。细节都被jQuery处理了，如果想了解细节，看jQuery的ajax部分代码。这里就给出一个参数配置&lt;code&gt;contentType&lt;/code&gt;消息主体的内容类型后，添加该内容的字符集：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;jQuery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;form&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;ajaxSubmit&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt; 
    &lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;some url&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;post&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="n"&gt;dataType&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;json&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="n"&gt;contentType&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;application/x-www-form-urlencoded; charset=utf-8&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="n"&gt;success&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;successFun&lt;/span&gt; 
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;枯燥的定义&lt;/h3&gt;
&lt;p&gt;不想看又不可不看的部分&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;URL只允许使用US-ASCII字符集中的可打印字符（0x20-0x7e范围内的字符）。并且，由于其在URL方案或HTTP协议内具有特殊含义的字符(= %等)，也不能使用，如：&lt;/p&gt;
&lt;h6&gt;保留字符&lt;/h6&gt;
&lt;p&gt;URL可以划分成若干个组件，协议、主机、路径等。有一些字符（:/?#[]@）是用作分隔不同组件的。例如：冒号用于分隔协议和主机，/用于分隔主机和路径，?用于分隔路径和查询参数，等等。还有一些字符（!$&amp;amp;'()*+,;=）用于在每个组件中起到分隔作用的，如=用于表示查询参数中的键值对，&amp;amp;符号用于分隔查询多个键值对。当组件中的普通数据包含这些特殊字符时，需要对其进行编码。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ietf.org/rfc/rfc3986.txt"&gt;RFC3986&lt;/a&gt;中指定了以下字符为保留字符(如URL包括这些字符必须对其编码)：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;!&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h6&gt;受限字符&lt;/h6&gt;
&lt;p&gt;还有一些字符，当他们直接放在Url中的时候，可能会引起解析程序的歧义。这些字符被视为不安全字符，原因有很多：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="err"&gt;空格：&lt;/span&gt;&lt;span class="n"&gt;URL&lt;/span&gt;&lt;span class="err"&gt;在传输的过程，或者用户在排版的过程，或者文本处理程序在处理&lt;/span&gt;&lt;span class="n"&gt;URL&lt;/span&gt;&lt;span class="err"&gt;的过程，都有可能引入无关紧要的空格，或者将那些有意义的空格给去掉。&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="err"&gt;引号以及&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;span class="err"&gt;：引号和尖括号通常用于在普通文本中起到分隔&lt;/span&gt;&lt;span class="n"&gt;Url&lt;/span&gt;&lt;span class="err"&gt;的作用&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="err"&gt;#：通常用于表示书签或者锚点&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="err"&gt;：百分号本身用作对不安全字符进行编码时使用的特殊字符，因此本身需要编码&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="err"&gt;：某一些网关或者传输代理会篡改这些字符&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h6&gt;非ASCII字符集&lt;/h6&gt;
&lt;p&gt;中文、韩文......，统一utf-8编码格式。&lt;/p&gt;
&lt;h3&gt;小结&lt;/h3&gt;
&lt;p&gt;网络上传输的是二进制，URL编码，其实就是把字符映射成二进制的过程。RFC定义合法URL只能是可打印ASCII字符来表示，也包括一些表示特殊含义的保留字符和保留字符（文件名或路径中含有，则需转换成。如，=表示查询参数键值，需转换成%3D），这样才能保证服务端正确编码的解析。
一些常见的URL编码字符：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;转换为&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;
&lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="err"&gt;转换为&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;25&lt;/span&gt;
&lt;span class="err"&gt;空格&lt;/span&gt; &lt;span class="err"&gt;转换为&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;
&lt;span class="err"&gt;新行&lt;/span&gt; &lt;span class="err"&gt;转换为&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="err"&gt;空字符&lt;/span&gt; &lt;span class="err"&gt;转换为&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mo"&gt;00&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;详细参见&lt;a href="http://www.w3schools.com/tags/ref_urlencode.asp"&gt;HTML URL Encoding Reference&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;最后的js中的三个方法&lt;/h3&gt;
&lt;p&gt;escape(unescape)，encodeURI(decodeURI)，encodeURIComponent(decodeURIComponent)---都是用于将不安全不合法的URL字符转换为合法的URL字符表示，不同点如下：&lt;/p&gt;
&lt;h6&gt;安全字符不同&lt;/h6&gt;
&lt;p&gt;不会对以下字符进行编码&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;escape&lt;/span&gt;&lt;span class="err"&gt;（&lt;/span&gt;&lt;span class="mi"&gt;69&lt;/span&gt;&lt;span class="err"&gt;个）：*/@&lt;/span&gt;&lt;span class="o"&gt;+-&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_0&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;zA&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Z&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;encodeURI&lt;/span&gt;&lt;span class="err"&gt;（&lt;/span&gt;&lt;span class="mi"&gt;82&lt;/span&gt;&lt;span class="err"&gt;个）：&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="err"&gt;#$&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;*+&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;/:&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="o"&gt;=?&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_&lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;zA&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Z&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;encodeURIComponent&lt;/span&gt;&lt;span class="err"&gt;（&lt;/span&gt;&lt;span class="mi"&gt;71&lt;/span&gt;&lt;span class="err"&gt;个）：&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;*-&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_&lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;zA&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Z&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h6&gt;兼容性不同&lt;/h6&gt;
&lt;p&gt;escape函数是从Javascript 1.0的时候就存在了，它返回的是unicode，其他两个函数是在Javascript 1.5才引入的。但是由于Javascript 1.5已经非常普及了，所以实际上使用encodeURI和encodeURIComponent并不会有什么兼容性问题。 &lt;/p&gt;
&lt;h6&gt;对Unicode字符的编码方式不同&lt;/h6&gt;
&lt;p&gt;这三个函数对于ASCII字符的编码方式相同，均是使用百分号+两位十六进制字符来表示。但是对于Unicode字符，escape的编码方式是%uxxxx，其中的xxxx是用来表示unicode字符的4位十六进制字符。这种方式已经被W3C废弃了。但是在ECMA-262标准中仍然保留着escape的这种编码语法。encodeURI和encodeURIComponent则使用UTF-8对非ASCII字符进行编码，然后再进行百分号编码。这是RFC推荐的。&lt;/p&gt;
&lt;p&gt;因此建议尽可能的使用encodeURI和encodeURIComponent这两个函数替代escape进行编码。&lt;/p&gt;
&lt;h6&gt;适用场合不同&lt;/h6&gt;
&lt;p&gt;encodeURI被用作对一个完整的URI进行编码，而encodeURIComponent被用作对URI的一个组件进行编码。从上面提到的安全字符范围表格来看，我们会发现，encodeURIComponent编码的字符范围要比encodeURI的大。我们上面提到过，保留字符一般是用来分隔URI组件（一个URI可以被切割成多个组件，参考预备知识一节）或者子组件（如URI中查询参数的分隔符），如：号用于分隔scheme和主机，?号用于分隔主机和路径。由于encodeURI操纵的对象是一个完整的的URI，这些字符在URI中本来就有特殊用途，因此这些保留字符不会被encodeURI编码，否则意义就变了。
组件内部有自己的数据表示格式，但是这些数据内部不能包含有分隔组件的保留字符，否则就会导致整个URI中组件的分隔混乱。因此对于单个组件使用encodeURIComponent，需要编码的字符就更多了。&lt;/p&gt;
&lt;h6&gt;保留及受限字符&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;% 保留作为编码字符的转义标志&lt;/li&gt;
&lt;li&gt;/ 保留作为路径组件中分隔路径段的定界符&lt;/li&gt;
&lt;li&gt;. 保留在路径组件中使用&lt;/li&gt;
&lt;li&gt;.. 保留在路径组件中使用&lt;/li&gt;
&lt;li&gt;
&lt;h1&gt;保留作为分段定界符使用&lt;/h1&gt;
&lt;/li&gt;
&lt;li&gt;? 保留作为查询字符串定界符使用&lt;/li&gt;
&lt;li&gt;; 保留作为参数定界符使用&lt;/li&gt;
&lt;li&gt;: 保留作为方案、用户/口令，以及主机/端口组件的定界符使用&lt;/li&gt;
&lt;li&gt;$ , + 保留&lt;/li&gt;
&lt;li&gt;@ &amp;amp; = 在某些方案的上下文中有特殊的含义，保留&lt;/li&gt;
&lt;li&gt;{ } | \ ^ ~ [ ] ` 由于各种Agent代理，比如各种网关的不安全处理，受限&lt;/li&gt;
&lt;li&gt;&amp;lt; &amp;gt; " 不安全；这些字符在URL范围外通常有意义的，如在文档中对URL自身进行定界&lt;/li&gt;
&lt;li&gt;0x00–0x1F, 0x7F 受限，这些十六进制范围内控字符都在US-ASCII字符集中不可打印区&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;0x7F 受限，十六进制范围内控字符都在US-ASCII字符集中不在7比特范围内&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;参拷&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.ruanyifeng.com/blog/2010/02/url_encoding.html"&gt;关于URL编码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://kb.cnblogs.com/page/133765/"&gt;URL编码与解码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://product.china-pub.com/3683063"&gt;HTTP权威指南&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">stormhouse</dc:creator><pubDate>Sat, 23 Nov 2013 20:53:00 +0800</pubDate><guid>tag:stormhouse.github.io,2013-11-23:posts/2013/urlbian-ma/</guid><category>encoding</category><category>python</category><category>http</category><category>url</category><category>tomcat</category></item><item><title>http中的字符编码</title><link>http://stormhouse.github.io/posts/2013/httpzhong-de-zi-fu-bian-ma/</link><description>&lt;p&gt;&lt;a href="http://stormhouse.github.io/posts/2013/zi-fu-bian-ma/"&gt;字符编码&lt;/a&gt;和&lt;a href="http://stormhouse.github.io/posts/2013/pythonzhong-de-zi-fu-bian-ma/"&gt;python中的字符编码&lt;/a&gt;两文对字符编码简单的介绍。现在开始讨论http中的编码问题，当完成&lt;code&gt;编码&lt;/code&gt;系列的文章后，开始完成一系统http的文章，本文还是需要一些http基本的知识。&lt;/p&gt;
&lt;p&gt;做为java出身的coder，今天还是用python语言来实现http的实例，java实现个东西太麻烦，Simple is better than complex.&lt;/p&gt;
&lt;h3&gt;响应头中的&lt;code&gt;Content-Type&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;我们知道http响应报文，包括两部分实体首部（&lt;code&gt;响应头&lt;/code&gt;）和实体主体（&lt;code&gt;响应主体&lt;/code&gt;），响应头是对主体内容的描述，告知浏览器怎么处理主体内容（文本，图片等等）。上代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#coding=utf-8&lt;/span&gt;

&lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;BaseHTTPServer&lt;/span&gt; &lt;span class="n"&gt;import&lt;/span&gt; &lt;span class="n"&gt;HTTPServer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BaseHTTPRequestHandler&lt;/span&gt;

&lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;MyRequestHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BaseHTTPRequestHandler&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;do_GET&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send_response&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send_header&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;Content&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;plain&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end_headers&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wfile&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt; &lt;span class="n"&gt;web&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;server&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;HTTPServer&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="mf"&gt;127.0.0.1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9000&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;MyRequestHandler&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;serve_forever&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;不了解上面代码没关系，你只需要知道它是一个简单的web服务（只支持GET），只返回一个文本。运行后，打开浏览器访问&lt;code&gt;http://localhost:9000&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Encoding Img" class="align-center" src="/img/encoding-http-ascii.png" title="http ascii" /&gt;&lt;/p&gt;
&lt;p&gt;看到上面我们预料之中的结果，如加入中文后，会出现什么情况&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#将self.wfile.write(&amp;#39;hello web&amp;#39;)替换为下行内容&lt;/span&gt;
&lt;span class="n"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wfile&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt; &lt;span class="n"&gt;web&lt;/span&gt; &lt;span class="err"&gt;编码&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;再次运行，访问浏览器&lt;/p&gt;
&lt;p&gt;&lt;img alt="Encoding Img" class="align-center" src="/img/encoding-http-zh.png" title="http ascii" /&gt;&lt;/p&gt;
&lt;p&gt;乱码出现了。返回浏览器的主体是&lt;code&gt;hello web 编码&lt;/code&gt;，响应头是&lt;code&gt;Content-Type:text/plain&lt;/code&gt;。只说明返回的是文本，而没具体说明该用哪个字符集来解析该文本(浏览器默认操作系统字符集处理gbk)。若改&lt;code&gt;Content-Type:text/plain;charset=utf-8&lt;/code&gt;，再次查看结果，乱码消失了。&lt;code&gt;charset参数是告知浏览器如何把主体内容中的二进制转换为字符&lt;/code&gt;，同理可以推断出该程序会将文本按utf-8编码处理成二进制，在网络上传输。&lt;/p&gt;
&lt;h3&gt;响应头中的&lt;code&gt;Content-Encoding&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Content-Encoding常见的取值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;gzip&lt;/span&gt;        &lt;span class="err"&gt;实体采用&lt;/span&gt;&lt;span class="n"&gt;GNU&lt;/span&gt; &lt;span class="n"&gt;zip&lt;/span&gt;&lt;span class="err"&gt;编码&lt;/span&gt;
&lt;span class="n"&gt;compress&lt;/span&gt;    &lt;span class="err"&gt;采用&lt;/span&gt;&lt;span class="n"&gt;Unix&lt;/span&gt;&lt;span class="err"&gt;的文件压缩程序&lt;/span&gt;
&lt;span class="n"&gt;deflate&lt;/span&gt;     &lt;span class="err"&gt;用&lt;/span&gt;&lt;span class="n"&gt;zlib&lt;/span&gt;&lt;span class="err"&gt;格式压缩&lt;/span&gt;
&lt;span class="n"&gt;identity&lt;/span&gt;    &lt;span class="err"&gt;没有进行任何编码&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上三种都是无损压缩算法，用于减少传输报文的大小写，不会导致信息损失。其中gzip效率是最高的。&lt;br /&gt;
与之请求对应的&lt;code&gt;Accept-Encoding&lt;/code&gt;相对应。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="vi"&gt;#coding&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nx"&gt;utf&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;

&lt;span class="nb"&gt;from&lt;/span&gt; &lt;span class="nx"&gt;BaseHTTPServer&lt;/span&gt; &lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nx"&gt;HTTPServer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;BaseHTTPRequestHandler&lt;/span&gt;

&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nx"&gt;gzip&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;cStringIO&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;urllib&lt;/span&gt;

&lt;span class="nx"&gt;def&lt;/span&gt; &lt;span class="nx"&gt;compressBuf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;zbuf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;cStringIO.StringIO&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;zfile&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;gzip.GzipFile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;wb&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  &lt;span class="n"&gt;fileobj&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;zbuf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;compresslevel&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;zfile.write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;zfile.close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;zbuf.getvalue&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="nb"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;MyRequestHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;BaseHTTPRequestHandler&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nx"&gt;def&lt;/span&gt; &lt;span class="nx"&gt;do_GET&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self.&lt;/span&gt;&lt;span class="nx"&gt;send_response&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self.&lt;/span&gt;&lt;span class="nx"&gt;send_header&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Content-Type&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;text/html&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self.&lt;/span&gt;&lt;span class="nx"&gt;send_header&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Content-Encoding&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;gzip&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="err"&gt;#若注释该行，客户端就会出错&lt;/span&gt;
        &lt;span class="bp"&gt;self.&lt;/span&gt;&lt;span class="nx"&gt;end_headers&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

        &lt;span class="n"&gt;content&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;#39;&amp;#39;&amp;lt;html&amp;gt;&lt;/span&gt;
&lt;span class="s1"&gt;        &amp;lt;head&amp;gt;&lt;/span&gt;
&lt;span class="s1"&gt;            &amp;lt;title&amp;gt;最简单的httpserver&amp;lt;/title&amp;gt;&lt;/span&gt;
&lt;span class="s1"&gt;            &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;/&amp;gt;&lt;/span&gt;
&lt;span class="s1"&gt;        &amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class="s1"&gt;        &amp;lt;body&amp;gt;就提供这一个页面&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;

        &lt;span class="n"&gt;zbuf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;compressBuf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;content&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="nx"&gt;print&lt;/span&gt; &lt;span class="nx"&gt;zbuf&lt;/span&gt;
        &lt;span class="bp"&gt;self.&lt;/span&gt;&lt;span class="nx"&gt;wfile.write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;zbuf&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;server&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;HTTPServer&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;127.0.0.1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9000&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nx"&gt;MyRequestHandler&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nx"&gt;server.serve_forever&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上述代码是将内容进行gzip压缩，返回到浏览器端，必须在响应头上加上&lt;code&gt;self.send_header('Content-Encoding','gzip')&lt;/code&gt;，若不加，浏览器按未压缩方式处理主体内容，就会出现乱码。&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;这块仅是简单的介绍几个http消息头，详细介绍会单独在将来的http系列的文章里&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">stormhouse</dc:creator><pubDate>Fri, 22 Nov 2013 21:10:00 +0800</pubDate><guid>tag:stormhouse.github.io,2013-11-22:posts/2013/httpzhong-de-zi-fu-bian-ma/</guid><category>encoding</category><category>python</category><category>http</category></item><item><title>python中的字符编码</title><link>http://stormhouse.github.io/posts/2013/pythonzhong-de-zi-fu-bian-ma/</link><description>&lt;p&gt;上篇&lt;a href="http://stormhouse.github.io/posts/2013/zi-fu-bian-ma/"&gt;字符编码&lt;/a&gt;对字符编码做了简单的介绍，除了演示几个简单的例子外，没有将&lt;code&gt;字符编码&lt;/code&gt;与&lt;code&gt;编程语言&lt;/code&gt;，看本文的标题相信就明白，这是与伟大的python结合一些实例（python版本为2.7.5）。&lt;/p&gt;
&lt;p&gt;准备工作，去码表（&lt;a href="http://ash.jp/code/cn/gb2312tbl.htm"&gt;GB2312&lt;/a&gt;, &lt;a href="http://www.tamasoft.co.jp/en/general-info/unicode.html"&gt;Unicode&lt;/a&gt;, &lt;a href="http://www.moransoft.com/chinesecode.html"&gt;UTF-8&lt;/a&gt;）查取&lt;code&gt;编码&lt;/code&gt;的GB2312和Unicode字符集编码及按gb2312和utf-8编码方式保存的二进制。注意，要亲自查一下 哦～～&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;编码&lt;/span&gt;                  &lt;span class="err"&gt;对应十六进制&lt;/span&gt;
&lt;span class="n"&gt;GB2312&lt;/span&gt;&lt;span class="err"&gt;字符集：&lt;/span&gt;        &lt;span class="n"&gt;b1e0&lt;/span&gt; &lt;span class="n"&gt;c2eb&lt;/span&gt;
&lt;span class="n"&gt;GB2312&lt;/span&gt;&lt;span class="err"&gt;编码&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;同上&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;     &lt;span class="n"&gt;b1e0&lt;/span&gt; &lt;span class="n"&gt;c2eb&lt;/span&gt;
&lt;span class="n"&gt;Unicode&lt;/span&gt;&lt;span class="err"&gt;字符集：&lt;/span&gt;       &lt;span class="mf"&gt;7f&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt; &lt;span class="mi"&gt;7801&lt;/span&gt;
&lt;span class="n"&gt;UTF&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="err"&gt;编码&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;同上&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;     &lt;span class="mf"&gt;7f&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt; &lt;span class="mi"&gt;7801&lt;/span&gt;
&lt;span class="n"&gt;UTF&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="err"&gt;编码&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;            &lt;span class="n"&gt;e7bc96&lt;/span&gt; &lt;span class="n"&gt;e7a081&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;字符串操作&lt;/h3&gt;
&lt;p&gt;话不多说，打开python解释器，输入：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;编码&amp;#39;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;
&lt;span class="err"&gt;&amp;#39;\&lt;/span&gt;&lt;span class="n"&gt;xb1&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;xe0&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;xc2&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;xeb&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将结果与码表查得的结果，对应着GB2312字符集。为什么呢？继续：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;import&lt;/span&gt; &lt;span class="n"&gt;sys&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getdefaultencoding&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="err"&gt;#返回当前系统所使用的默认字符编码&lt;/span&gt;
&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;ascii&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;除一些IDE外，python是按操作系统默认字符编码来处理的。这里是ascii。&lt;/p&gt;
&lt;p&gt;python支持unicode：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;编码&amp;#39;&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="n"&gt;unicode&lt;/span&gt;&lt;span class="err"&gt;编码&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;
&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;\&lt;/span&gt;&lt;span class="n"&gt;u7f16&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;u7801&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;utf-8：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;编码&amp;#39;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;
&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;\&lt;/span&gt;&lt;span class="n"&gt;u7f16&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;u7801&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;unicode&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;encode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;utf&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;
&lt;span class="err"&gt;&amp;#39;\&lt;/span&gt;&lt;span class="n"&gt;xe7&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;xbc&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;x96&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;xe7&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;xa0&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;x81&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;u1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;decode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;utf&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;u1&lt;/span&gt;
&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;\&lt;/span&gt;&lt;span class="n"&gt;u7f16&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;u7801&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;综上，可与查得的结果相同。&lt;/p&gt;
&lt;p&gt;python中的str，unicode对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;str: str对象其实就是"8-bit string" ，字节字符串，本质上类似java中的byte[]。decode&lt;/li&gt;
&lt;li&gt;unicode: unicode对象应该才是等同于java中的String对象，或本质上是java的char[]。encode&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;unicode才是真正意义上的字符串：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;编码&amp;#39;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="mi"&gt;4&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;编码&amp;#39;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="mi"&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;详细请参见&lt;a href="http://www.cnblogs.com/huxi/archive/2010/12/05/1897271.html"&gt;python的str，unicode对象的encode和decode方法&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;文件操作&lt;/h3&gt;
&lt;h6&gt;读文件&lt;/h6&gt;
&lt;p&gt;内置的open()方法打开文件时，read()读取的是str，读取后需要使用正确的编码格式进行decode()。&lt;/p&gt;
&lt;p&gt;如保存为ascii格式的文本文件encoding-ascii.txt，内容为'编码'。对该文本读取：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#coding=utf-8&lt;/span&gt;

&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;encoding&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;ascii&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;txt&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="n"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;      &lt;span class="err"&gt;#编码&lt;/span&gt;

&lt;span class="n"&gt;u&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;decode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;gb2312&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;unicode&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;       &lt;span class="err"&gt;#编码&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面是正确的编码处理方式。假如读取保存为utf-8格式的文件encoding-utf8.txt会出现什么情况：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#coding=utf-8&lt;/span&gt;

&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;encoding&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;utf8&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;txt&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="n"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;      &lt;span class="err"&gt;#锘跨紪鐮&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;乱码&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


&lt;span class="n"&gt;u&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;decode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;gb2312&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;#报错。正确方式：&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;decode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;utf&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="cp"&gt;# UnicodeDecodeError: &amp;#39;gb2312&amp;#39; codec can&amp;#39;t decode bytes in position 4-5: llegal multibyte sequence&lt;/span&gt;
&lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;故正确处理方式为：&lt;br /&gt;
使用codecs模块中的open方法，可指定编码方式打开文件，该方法返回的是unicode（注意：内置open返回的是str）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#coding=utf-8&lt;/span&gt;

&lt;span class="n"&gt;import&lt;/span&gt; &lt;span class="n"&gt;codecs&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;codecs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;encoding&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;utf8&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;txt&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;encoding&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;utf&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;u&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;unicode&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="n"&gt;repr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;\&lt;/span&gt;&lt;span class="n"&gt;u7f16&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;u7801&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;

&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;encode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;gb2312&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;       &lt;span class="err"&gt;#编码&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h6&gt;写文件&lt;/h6&gt;
&lt;p&gt;内置的write()写入时，如果参数是unicode，则需要使用你希望写入的编码进行encode()，如果是其他编码格式的str，则需要先用该str的编码进行decode()，转成unicode后再使用写入的编码进行encode()。如果直接将unicode作为参数传入write()方法，Python将先使用源代码文件声明的字符编码进行编码然后写入。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#coding=utf-8&lt;/span&gt;

&lt;span class="n"&gt;u&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;编码&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;txt&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;w&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="cp"&gt;# 编码成UTF-8编码的str&lt;/span&gt;
&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;encode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;gb2312&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;查看test.txt文件，可得保存的格式为ascii。&lt;/p&gt;
&lt;p&gt;codecs模块写入时，如果参数是unicode，则使用open()时指定的编码进行编码后写入；如果是str，则先根据源代码文件声明的字符编码，解码成unicode后再进行前述操作。相对内置的open()来说，这个方法比较不容易在编码上出现问题。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#coding=utf-8&lt;/span&gt;

&lt;span class="n"&gt;import&lt;/span&gt; &lt;span class="n"&gt;codecs&lt;/span&gt;
&lt;span class="n"&gt;u&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;编码&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;f1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;codecs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;test1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;txt&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;encoding&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;gb2312&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="n"&gt;utf&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;
&lt;span class="cp"&gt;# 写入unicode&lt;/span&gt;
&lt;span class="n"&gt;f1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="cp"&gt;# 写入str，自动进行解码编码操作(貌似没法自动转化TODO)&lt;/span&gt;
&lt;span class="cp"&gt;# GBK编码的str&lt;/span&gt;
&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;汉&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="n"&gt;repr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;\&lt;/span&gt;&lt;span class="n"&gt;xba&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;xba&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="cp"&gt;# 这里会先将GBK编码的str解码为unicode再编码为UTF-8写入&lt;/span&gt;
&lt;span class="n"&gt;f1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;decode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;utf&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;f1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;网络(HTTP)操作&lt;/h3&gt;
&lt;p&gt;[传送门][]&lt;/p&gt;
&lt;h3&gt;sys/locale模块关于编码相关的方法&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="nx"&gt;sys&lt;/span&gt;
&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="nx"&gt;locale&lt;/span&gt;

&lt;span class="nx"&gt;def&lt;/span&gt; &lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;print&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;%s.%s(): %s&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;__module__&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;__name__&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;

&lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;返回当前系统所使用的默认字符编码&lt;/span&gt;
&lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;sys&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getdefaultencoding&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;返回用于转换&lt;/span&gt;&lt;span class="nx"&gt;Unicode&lt;/span&gt;&lt;span class="err"&gt;文件名至系统文件名所使用的编码&lt;/span&gt;
&lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;sys&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getfilesystemencoding&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;获取默认的区域设置并返回元祖&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;语言&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;编码&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;locale&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getdefaultlocale&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;返回用户设定的文本数据编码&lt;/span&gt;
&lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;文档提到&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;only&lt;/span&gt; &lt;span class="nx"&gt;returns&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="nx"&gt;guess&lt;/span&gt;
&lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;locale&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getpreferredencoding&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="nx"&gt;xba&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="nx"&gt;xba&lt;/span&gt;&lt;span class="err"&gt;是&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;汉&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;的&lt;/span&gt;&lt;span class="nx"&gt;GBK&lt;/span&gt;&lt;span class="err"&gt;编码&lt;/span&gt;
&lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="nx"&gt;mbcs&lt;/span&gt;&lt;span class="err"&gt;是不推荐使用的编码，这里仅作测试表明为什么不应该用&lt;/span&gt;
&lt;span class="nx"&gt;print&lt;/span&gt; &lt;span class="nx"&gt;r&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;#39;\xba\xba&amp;#39;.decode(&amp;#39;mbcs&amp;#39;):&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;repr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;\xba\xba&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;decode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;mbcs&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="err"&gt;#在笔者的&lt;/span&gt;&lt;span class="nx"&gt;Windows&lt;/span&gt;&lt;span class="err"&gt;上的结果&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;区域设置为中文&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;简体&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;中国&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="nx"&gt;sys&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getdefaultencoding&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;ascii&lt;/span&gt;
&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="nx"&gt;sys&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getfilesystemencoding&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;mbcs&lt;/span&gt;
&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="nx"&gt;locale&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getdefaultlocale&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;zh_CN&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;cp936&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="nx"&gt;locale&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getpreferredencoding&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;cp936&lt;/span&gt;
&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;\xba\xba&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;decode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;mbcs&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;u&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;\u6c49&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;总结&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用字符编码声明，并且同一工程中的所有源代码文件使用相同的字符编码声明。&lt;/li&gt;
&lt;li&gt;抛弃str，全部使用unicode。&lt;code&gt;u = u'编码'&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用codecs.open()替代内置的open()。&lt;/li&gt;
&lt;li&gt;绝对需要&lt;code&gt;避免&lt;/code&gt;使用的字符编码：MBCS/DBCS和UTF-16。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里说的MBCS不是指GBK什么的都不能用，而是不要使用Python里名为'MBCS'的编码，除非程序完全不移植。&lt;br /&gt;
Python中编码'MBCS'与'DBCS'是同义词，指当前Windows环境中MBCS指代的编码。Linux的Python实现中没有这种编码，所以一旦移植到Linux一定会出现异常！另外，只要设定的Windows系统区域不同，MBCS指代的编码也是不一样的。&lt;/p&gt;
&lt;h6&gt;MBCS&lt;/h6&gt;
&lt;p&gt;计算机世界里很快就有了其他语言，单字节的ASCII已无法满足需求。后来每个语言就制定了一套自己的编码，由于单字节能表示的字符太少，而且同时也需要与ASCII编码保持兼容，所以这些编码纷纷使用了多字节来表示字符，如GBxxx、BIGxxx等等，他们的规则是，如果第一个字节是\x80以下，则仍然表示ASCII字符；而如果是\x80以上，则跟下一个字节一起（共两个字节）表示一个字符，然后跳过下一个字节，继续往下判断。&lt;/p&gt;
&lt;p&gt;这里，IBM发明了一个叫Code Page的概念，将这些编码都收入囊中并分配页码，GBK是第936页，也就是CP936。所以，也可以使用CP936表示GBK。&lt;/p&gt;
&lt;p&gt;MBCS(Multi-Byte Character Set)是这些编码的统称。目前为止大家都是用了双字节，所以有时候也叫做DBCS(Double-Byte Character Set)。必须明确的是，MBCS并不是某一种特定的编码，Windows里根据你设定的区域不同，MBCS指代不同的编码，而Linux里无法使用MBCS作为编码。在Windows中你看不到MBCS这几个字符，因为微软为了更加洋气，使用了ANSI来吓唬人，记事本的另存为对话框里编码ANSI就是MBCS。同时，在简体中文Windows默认的区域设定里，指代GBK。&lt;/p&gt;
&lt;h3&gt;参拷&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.cnblogs.com/huxi/archive/2010/12/05/1897271.html"&gt;Python字符编码详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://appofis.iteye.com/blog/443206"&gt;python的str，unicode对象的encode和decode方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://docs.python.org/2/library/codecs.html#standard-encodings"&gt;Standard Encodings&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">stormhouse</dc:creator><pubDate>Thu, 21 Nov 2013 22:38:00 +0800</pubDate><guid>tag:stormhouse.github.io,2013-11-21:posts/2013/pythonzhong-de-zi-fu-bian-ma/</guid><category>encoding</category><category>python</category></item><item><title>字符编码</title><link>http://stormhouse.github.io/posts/2013/zi-fu-bian-ma/</link><description>&lt;hr /&gt;
&lt;p&gt;每个软件开发人员应该无条件掌握的知识！&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;字符编码是一个基础话题，不管你从事哪种语言的开发，还是前端、后端或网络开发，乱码问题一直困扰着像我这样的低水平的生手。接下来的内容是我参考了好多的文章，并整理的便于自己理解的脉络。&lt;br /&gt;
就像别人一样的开场：计算机比较傻，在它的世界里只有 &lt;code&gt;1&lt;/code&gt; &lt;code&gt;0&lt;/code&gt;，如何才让人类可理解的&lt;strong&gt;字符&lt;/strong&gt;(Character,如字母、数字，一些符号，汉字...)打印到显示屏幕上呢。这需要有一个从由&lt;code&gt;1&lt;/code&gt; &lt;code&gt;0&lt;/code&gt;组合成的序列到可打印字符的一个&lt;strong&gt;映射&lt;/strong&gt; (编码Encoding)，可打印的字符是一个&lt;strong&gt;集合&lt;/strong&gt;(字符集Charset)。在这里就引出了几个概念:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字符(Character)：是文字与符号的总称，包括文字、图形符号、数学符号等。&lt;/li&gt;
&lt;li&gt;字符集(Charset)：即字符的集合，规定了在这些集合里面有哪些字符。&lt;/li&gt;
&lt;li&gt;字符编码(Encoding)：就是规定用一个字节还是多个字节来存储一个字符，用固定的二进制码值表示某个字符。&lt;/li&gt;
&lt;li&gt;字节(byte)：计算机中存储数据的单元，一个8位的二进制数，是一个很具体的存储空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一看到这样定义我就头大，还是来具体的例子，故事开始了&lt;/p&gt;
&lt;h3&gt;美国人发明了计算机&lt;/h3&gt;
&lt;p&gt;很久很久以前，计算机世界只有美国人。英语语言里字符很少，大小写字母共26*2个，阿拉伯数字10个，其它的一些符号(如 ! " # $ % &amp;amp;等)，这些可打印字符一共95个。计算机的的回车键，删除键等控制符33个。总和只有128个。于是，对于他们来说，很自然，那么计算机中用8位就可以表示他们的所有字符了吧。于是他们将8位称作一个字节，计算机的8位表示的每个数字对应了一个英文字符，画了一张表（&lt;a href="http://www.asciitable.com/"&gt;ASCII码表&lt;/a&gt;），这就是ASCII编码(American Standard Code for Information Interchange，美国信息互换标准代码)。  &lt;br /&gt;
这里的128个字符集合，就叫&lt;code&gt;字符集&lt;/code&gt;,对应的二进制，就是&lt;code&gt;字符编码&lt;/code&gt;。你可以做个 &lt;strong&gt;测试&lt;/strong&gt; ，新一个文本文件，内容为&lt;code&gt;abcdabcd&lt;/code&gt;,保存为ASCII编码格式，用十六进制编辑器打开，看是否与&lt;a href="http://www.ascii-code.com/"&gt;ASCII码表&lt;/a&gt;中的值对应。
win7系统中&lt;/p&gt;
&lt;p&gt;&lt;img alt="Encoding Img" class="align-center" src="/img/encoding-win.png" title="ascii encoding in windows" /&gt;&lt;/p&gt;
&lt;p&gt;linux系统中&lt;/p&gt;
&lt;p&gt;&lt;img alt="Encoding Img" class="align-center" src="/img/encoding-linux-hex.png" title="ascii encoding in linux" /&gt;&lt;/p&gt;
&lt;p&gt;上面除了对应的&lt;code&gt;61 62 63 64&lt;/code&gt;，还有&lt;code&gt;0D 0A&lt;/code&gt;，这是windows系统中断行的标志，linux中是&lt;code&gt;0A&lt;/code&gt;，默认最后一行有添加该标志。详细请参见&lt;a href="http://codingstandards.iteye.com/blog/810900"&gt;将DOS格式文本文件转换成UNIX格式&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;计算机传到了欧洲&lt;/h3&gt;
&lt;p&gt;欧洲是有好多个国家的，他们的每个国家也都有自己的文字，比如拉丁文，希腊文等。怎么办呢？于是想到，你美国人指定的ASCII码表里面不是只有127个字符吗，后面128-255的字符不是说待定吗，好吧，我们就不客气了。于是欧洲人就将各种奇怪的语言塞入127后面的字符中，形成了一系列的ISO 8859字符集。比如希腊文塞入ASCII，就形成了ISO/IEC 8859-7，西欧语种塞入ASCII就形成了ISO/IEC 8859-1，ISO/IEC 8859-1也叫做latin-1。（对，就是mysql里面经常见到的编码）&lt;/p&gt;
&lt;p&gt;下面是&lt;a href="http://zh.wikipedia.org/wiki/ISO/IEC_8859"&gt;ISO 8859&lt;/a&gt;现有的15个字符集&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ISO/IEC 8859-1 (Latin-1) - 西欧语言 &lt;/li&gt;
&lt;li&gt;ISO/IEC 8859-2 (Latin-2) - 中欧语言 &lt;/li&gt;
&lt;li&gt;ISO/IEC 8859-3 (Latin-3) - 南欧语言。世界语也可用此字符集显示。 &lt;/li&gt;
&lt;li&gt;ISO/IEC 8859-4 (Latin-4) - 北欧语言 &lt;/li&gt;
&lt;li&gt;ISO/IEC 8859-5 (Cyrillic) - 斯拉夫语言 &lt;/li&gt;
&lt;li&gt;ISO/IEC 8859-6 (Arabic) - 阿拉伯语 &lt;/li&gt;
&lt;li&gt;ISO/IEC 8859-7 (Greek) - 希腊语 &lt;/li&gt;
&lt;li&gt;ISO/IEC 8859-8 (Hebrew) - 希伯来语（视觉顺序） &lt;/li&gt;
&lt;li&gt;ISO 8859-8-I - 希伯来语（逻辑顺序） &lt;/li&gt;
&lt;li&gt;ISO/IEC 8859-9（Latin-5 或 Turkish）- 它把Latin-1的冰岛语字母换走，加入土耳其语字母。 &lt;/li&gt;
&lt;li&gt;ISO/IEC 8859-10（Latin-6 或 Nordic）- 北日耳曼语支，用来代替Latin-4。 &lt;/li&gt;
&lt;li&gt;ISO/IEC 8859-11 (Thai) - 泰语，从泰国的 TIS620 标准字集演化而来。 &lt;/li&gt;
&lt;li&gt;ISO/IEC 8859-13（Latin-7 或 Baltic Rim）- 波罗的语族 &lt;/li&gt;
&lt;li&gt;ISO/IEC 8859-14（Latin-8 或 Celtic）- 凯尔特语族 &lt;/li&gt;
&lt;li&gt;ISO/IEC 8859-15 (Latin-9) - 西欧语言，加入Latin-1欠缺的芬兰语字母和大写法语重音字母，以及欧元（€）符号。 &lt;/li&gt;
&lt;li&gt;ISO/IEC 8859-16 (Latin-10) - 东南欧语言。主要供罗马尼亚语使用，并加入欧元符号。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;该部分内容我们不用太关注，接下来&lt;/p&gt;
&lt;h3&gt;伟大的中国人终于用上了电脑&lt;/h3&gt;
&lt;p&gt;中文可不得了，文字博大精深，字符远远超过了256个。所以我们无法使用ASCII的扩展了。怎么办呢？ 1981年的时候，国家派一批人来做了这个事情，他们统计出所有的中文大概有6000多个字符（后来证明这些人的水品也是有限，好多字符都没有搜出来，于是就有了多种的中文编码），用两个字节（16bit）来表示，16bit能表示的是65536个字符，太够了。我们将16bit分为前8bit和后8bit&lt;br /&gt;
如果前8bit小于127（英文ASCII），那么这个8bit就是表示英文&lt;br /&gt;
如果前8bit大于127，那么这8bit和后面的8bit合起来表示一个中文 
这就是&lt;a href="http://ash.jp/code/cn/gb2312tbl.htm"&gt;GB2312&lt;/a&gt;，GB2312 是对 ASCII 的中文扩展&lt;/p&gt;
&lt;p&gt;好了，后来某些领导发现，他的名字没法编码了，这个问题出来了。6000个汉字还不足以囊括所有中文，国家在1995年又组织了一批人，继续搜罗一些生僻字，一共搜集出了21886个汉字和字符，形成了GBK编码，GBK编码向下兼容GB2312。&lt;/p&gt;
&lt;p&gt;再后来发现了，一些满文，蒙古文啥的少数名族的语言没有编辑到GBK中，继续编辑收录，形成了GB18030编码。&lt;/p&gt;
&lt;p&gt;从ASCII、GB2312、GBK到GB18030，这些编码方法是向下兼容的，即同一个字符在这些方案中总是有相同的编码，后面的标准支持更多的字符。在这些编码中，英文和中文可以统一地处理。区分中文编码的方法是高字节的最高位不为0。按照程序员的称呼，GB2312、GBK到GB18030都属于双字节字符集 (DBCS,Double Byte Charecter Set)。&lt;br /&gt;
在DBCS系列标准里，最大的特点是两字节长的汉字字符和一字节长的英文字符并存于同一套编码方案里，因此他们写的程序为了支持中文处 理，必须要注意字串里的每一个字节的值，如果这个值是大于127的，那么就认为一个双字节字符集里的字符出现了&lt;/p&gt;
&lt;h3&gt;自由的台湾人民&lt;/h3&gt;
&lt;p&gt;台湾是汉字是繁体字，当然不能使用大陆编辑使用的GBXX系列编码了，于是他们自己搞了一套&lt;a href="http://ash.jp/code/cn/big5tbl.htm"&gt;BIG5&lt;/a&gt;中文编码，收录了13060个汉字和字符。但是这里要注意，BIG5的编码映射表和GBXX系列的就完全不一样了，比如同一个“中”字，在BIG5和GB2312中就是两个完全不同的字节。这里就会有乱码出现了，比如（"陶喆"和"陶吉吉"），各种简体中文和繁体文的转码工具就出现了。&lt;br /&gt;
五种中文套装软体：文书处理，资料库，试算表，通讯，绘图。大致的意思是这套编码主要使用于这5个领域&lt;/p&gt;
&lt;h3&gt;各国人民的的UNICODE&lt;/h3&gt;
&lt;p&gt;由于每种语言都制定了自己的字符集，导致最后存在的各种字符集实在太多，在国际交流中要经常转换字符集非常不便。因此，产生了Unicode字符集，它固定使用16 bits（两个字节）来表示一个字符，共可以表示65536个字符 &lt;/p&gt;
&lt;p&gt;对于ascii里的那些“半角”字符，UNICODE 包持其原编码不变，只是将其长度由原来的8位扩展为16位，而其他文化和语言的字符则全部重新统一编码。由于"半角"英文符号只需要用到低8位，所以其高 8位永远是0，因此这种大气的方案在保存英文文本时会多浪费一倍的空间。Unicode使用的通用的字符集叫做UCS。这个字符集就是一个大的字符空间，每个语种都在这个字符空间内划分一段领域。现在应用的UCS是UCS-2，意思就是不管是英文中文，统一使用两个字节（16bit）来进行字符分配。UCS-2字符集可以表示216（即65536）个字符。已经基本满足世界上所有语言了。如果不够怎么办？已经有预定方案UCS-4（用4个字节表示一个字符）。  &lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Unicode只是一个字符集，全纳了世界所有的符号，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。&lt;/li&gt;
&lt;li&gt;UTF-xx是Unicode的具体实现方式。&lt;/li&gt;
&lt;li&gt;UTF-16是Unicode最基本的实现。Unicode使用16bit表示一个字符，UTF-16就是直接将字符集的映射搬过来而已。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;UTF-8&lt;/h3&gt;
&lt;p&gt;本来这样就已经很美好了，但是美国人又不干了，毕竟互联网70％以上的信息仍然是英。凭什么每个英语字符要占用2个字节？凭什么占用了我们的带宽和CPU？于是一帮英语体系的外国人讨论出了UTF-8这种字符编码。UTF-8就是这样一个为了提高英文存取效率的字符集转换格式(Unicode Transformation Form 8-bit form)&lt;br /&gt;
UTF-8这种编码是怎么回事呢？ &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;英文字符，和ASCII码一样，占用一个字节。因此对于英语字母，UTF-8编码和ASCII码是相同的。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于n字节的符号（n&amp;gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。&lt;/p&gt;
&lt;p&gt;Unicode符号范围       UTF-8编码方式&lt;br /&gt;
(十六进制)            （二进制）&lt;br /&gt;
0000 0000-0000 007F | 0xxxxxxx&lt;br /&gt;
0000 0080-0000 07FF | 110xxxxx 10xxxxxx&lt;br /&gt;
0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx&lt;br /&gt;
0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx  &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里演示一个中文字“汉”，&lt;a href="http://www.chi2ko.com/tool/CJK.htm"&gt;查得&lt;/a&gt;unicode 表式为&lt;code&gt;0x6C49&lt;/code&gt;，二进制为&lt;code&gt;0110 1100 0100 1001&lt;/code&gt;
根据上表，可以发现&lt;code&gt;0x6C49&lt;/code&gt;处在第三行的范围内（&lt;code&gt;0000 0800-0000 FFFF&lt;/code&gt;），因此"严"的UTF-8编码需要三个字节，即格式是"1110xxxx 10xxxxxx 10xxxxxx"。然后，从"严"的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，"汉"的UTF-8编码是"&lt;code&gt;11100110 10110001 10001001&lt;/code&gt;"，转换成十六进制就是&lt;code&gt;0xE6B189&lt;/code&gt;。示例如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Encoding Img" class="align-center" src="/img/encoding-win-unicode.png" title="" /&gt;&lt;/p&gt;
&lt;p&gt;图中十六进制内容是&lt;code&gt;FF FE 49 6C&lt;/code&gt;，肿么回事？这是保存的两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Little endian: 第二个字节在前&lt;/li&gt;
&lt;li&gt;Big endian： 第一个字节在前&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如保存为Big endian方式：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Encoding Img" class="align-center" src="/img/encoding-win-unicode-big.png" title="" /&gt;&lt;/p&gt;
&lt;p&gt;保存为UTF-8方式&lt;/p&gt;
&lt;p&gt;&lt;img alt="Encoding Img" class="align-center" src="/img/encoding-win-utf8.png" title="" /&gt;&lt;/p&gt;
&lt;p&gt;上图中的十六进制为&lt;code&gt;EF BB BF E6 B1 89&lt;/code&gt;，肿么会多出来&lt;code&gt;EF BB BF&lt;/code&gt;呢，参见&lt;a href="http://www.zhihu.com/question/20167122"&gt;带BOM的UTF-8&lt;/a&gt;&lt;br /&gt;
如不想带bom，使用editplus编辑器另存为无BOM&lt;/p&gt;
&lt;p&gt;&lt;img alt="Encoding Img" class="align-center" src="/img/encoding-win-utf8-nobom.png" title="utf8 encoding without bom" /&gt;&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;主要搞清两个重要概念&lt;code&gt;字符集&lt;/code&gt;和&lt;code&gt;字符编码&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字符集：即字符的集合，规定了在这些集合里面有哪些字符，也规定了二进制表示。Ascii是一个集合，gb2312兼容Ascii。&lt;/li&gt;
&lt;li&gt;字符编码：简单讲就是规定用一个字节还是多个字节来存储一个字符。编码方式决定了实际存储的二进制。如GB2312中，字母数字一个字节存储，汉字两个字节存储。Unicode中，UTF-16是按Unicode字符集表示的二进制存储，UTF-8是按字符所在Unicode范围进行一个转换。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下编码系列的内容可能会包括&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;URL Encode&lt;/li&gt;
&lt;li&gt;web方面乱码的处理&lt;/li&gt;
&lt;li&gt;java python中的编码处理&lt;/li&gt;
&lt;li&gt;base64编码&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;码表&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.ascii-code.com/"&gt;Ascii&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://ash.jp/code/cn/gb2312tbl.htm"&gt;GB2312&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.khngai.com/chinese/charmap/tblgbk.php"&gt;GBK&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://unicode-table.com/en/"&gt;Unicode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.moransoft.com/chinesecode.html"&gt;UTF-8&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;参拷&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://smartzxy.iteye.com/blog/692602"&gt;研究了一下字符编码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.cnblogs.com/yjf512/archive/2012/04/21/2461084.html"&gt;编码史记&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html"&gt;字符编码笔记：ASCII，Unicode和UTF-8&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.zhihu.com/question/20167122"&gt;「带 BOM 的 UTF-8」和「无 BOM 的 UTF-8」有什么区别？网页代码一般使用哪个？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.oasisfeng.com/2006/10/19/full-cjk-unicode-range/"&gt;完整的CJK Unicode范围（5.0版）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chi2ko.com/tool/CJK.htm"&gt;字体编辑用中日韩汉字Unicode编码表&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(完)&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">stormhouse</dc:creator><pubDate>Wed, 20 Nov 2013 21:31:00 +0800</pubDate><guid>tag:stormhouse.github.io,2013-11-20:posts/2013/zi-fu-bian-ma/</guid><category>encoding</category></item></channel></rss>